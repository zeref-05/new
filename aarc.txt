#rod cutting
def cutRod(price, index, n):
	if index == 0:
		return n*price[0]
	notCut = cutRod(price,index - 1,n)
	cut = float("-inf")
	rod_length = index + 1

	if (rod_length <= n):
		cut = price[index]+cutRod(price,index,n - rod_length)

	return max(notCut, cut)	
arr = [ 1, 5, 8, 9, 10, 17, 17, 20 ]
print("the Array :" , arr)
size = len(arr)
print("the size of the arr :", size)
print("Maximum Obtainable Value is",cutRod(arr, size - 1, size)) 


#merge sort
def mergesort(list1):
   if len(list1)>1:
     mid=len(list1)//2
     left_list=list1[:mid]
     right_list=list1[mid:]
     mergesort(left_list)
     mergesort(right_list)
     i=0
     j=0
     k=0
     while i<len(left_list) and j<len(right_list):
         if left_list[i]<right_list[j]:
          list1[k]=left_list[i]
          i=i+1
          k=k+1
         else:
             list1[k]=right_list[j]
             j=j+1
             k=k+1
     while i<len(left_list):
         list1[k]=left_list[i]
         i=i+1
         k=k+1
     while j<len(right_list):
         list1[k]=right_list[j]
         j=j+1
         k=k+1
num=int(input("How many elements you want in list:"))
list1 = [int(input("Enter element: ")) for _ in range(num)]
mergesort(list1)
print("sorted list is :",list1)


#permute by sorting 
import random
def permute_by_sorting(arr):
    l = len(arr)
    keys = [random.random() for _ in range(l)]  
    combined = list(zip(keys, arr))  
    combined.sort(key=lambda x: x[0]) 
    return [element for (_, element) in combined]
original_array = [1, 2, 3, 4, 5]
permuted_array = permute_by_sorting(original_array)
print("Original Array:", original_array)
print("Permuted Array (using permute-by-sorting):", permuted_array)


#permute by cyclic
import random
def permute_by_cyclic(arr):
    arr_copy = arr[:]  # Make a copy
    l = len(arr_copy)
    for i in range(l):
        j = random.randint(i, l - 1)
        arr_copy[i], arr_copy[j] = arr_copy[j], arr_copy[i]
    return arr_copy

original_array = [1, 2, 3, 4, 5]
permuted_array = permute_by_cyclic(original_array)
print("Original Array:", original_array)
print("Permuted Array (using permute-by-cyclic):", permuted_array)


#LCS
def lcs(X, Y, m, n):
    L = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    index = L[m][n]
    lcs_seq = [""] * index
    i, j = m, n
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            lcs_seq[index - 1] = X[i - 1]
            i -= 1
            j -= 1
            index -= 1
        elif L[i - 1][j] > L[i][j - 1]:
            i -= 1
        else:
            j -= 1
    print("LCS is:", "".join(lcs_seq))
    return L[m][n]

X = input("Enter first string: ")
Y = input("Enter second string: ")
m, n = len(X), len(Y)
length = lcs(X, Y, m, n)
print("Length of LCS is:", length)


#krushkals
class DisjointSet:
    def __init__(self, vertices):
        self.parent = {v: v for v in vertices}
        self.rank = {v: 0 for v in vertices}

    def find(self, v):
        if self.parent[v] != v:
            self.parent[v] = self.find(self.parent[v])
        return self.parent[v]

    def union(self, v1, v2):
        root1 = self.find(v1)
        root2 = self.find(v2)

        if root1 != root2:
            if self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
            elif self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            else:
                self.parent[root2] = root1
                self.rank[root1] += 1

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def add_edge(self, src, dest, weight):
        self.graph.append((src, dest, weight))

    def kruskal(self):
        result = []
        self.graph = sorted(self.graph, key=lambda item: item[2])
        disjoint_set = DisjointSet(range(self.V))
        for edge in self.graph:
            src, dest, weight = edge
            if disjoint_set.find(src) != disjoint_set.find(dest):
                result.append(edge)
                disjoint_set.union(src, dest)
        return result

g = Graph(4)
g.add_edge(0, 1, 10)
g.add_edge(0, 2, 6)
g.add_edge(0, 3, 5)
g.add_edge(1, 3, 15)
g.add_edge(2, 3, 4)

minimum_spanning_tree = g.kruskal()
print("Edges in the Minimum Spanning Tree using Kruskal's Algorithm:")
for edge in minimum_spanning_tree:
    print(f"{edge[0]} - {edge[1]} : {edge[2]}")


#dijkstra
import heapq

class Graph:
    def __init__(self):
        self.vertices = {}

    def add_edge(self, src, dest, weight):
        if src not in self.vertices:
            self.vertices[src] = []
        self.vertices[src].append((dest, weight))
        # Add this so disconnected nodes are included in distance dictionary
        if dest not in self.vertices:
            self.vertices[dest] = []

    def dijkstra(self, start):
        distances = {vertex: float('inf') for vertex in self.vertices}
        distances[start] = 0
        pq = [(0, start)]
        while pq:
            current_distance, current_vertex = heapq.heappop(pq)
            if current_distance > distances[current_vertex]:
                continue
            for neighbor, weight in self.vertices[current_vertex]:
                distance = current_distance + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        return distances

g = Graph()
g.add_edge('A', 'B', 4)
g.add_edge('A', 'C', 2)
g.add_edge('B', 'C', 5)
g.add_edge('B', 'D', 10)
g.add_edge('C', 'D', 3)
g.add_edge('D', 'E', 7)
g.add_edge('E', 'F', 2)
g.add_edge('F', 'D', 2)

source_vertex = 'A'
shortest_distances = g.dijkstra(source_vertex)

print(f"Shortest distances from vertex {source_vertex}:")
for vertex, distance in shortest_distances.items():
    print(f"To vertex {vertex}: {distance}")



#extended Euclid
def extended_euclidean_algorithm(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_euclidean_algorithm(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

num1 = 48
print('Number 1:', num1)
num2 = 18
print('Number 2:', num2)

# Calculate GCD using Euclid's algorithm
result_gcd = gcd(num1, num2)
print(f"GCD of {num1} and {num2} using Euclid's algorithm: {result_gcd}")

# Calculate GCD and values of x and y using extended Euclidean algorithm
gcd_value, x, y = extended_euclidean_algorithm(num1, num2)
print(f"GCD of {num1} and {num2} using extended Euclidean algorithm: {gcd_value}")
print(f"x and y values such that {gcd_value} = {num1} * {x} + {num2} * {y}")

#euclid
def euclids_theorem(p, a):
    # Check if p is prime
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    if is_prime(p) and p > 1 and p != a:
        # Compute gcd directly
        def gcd(x, y):
            while y != 0:
                x, y = y, x % y
            return x
        if gcd(a, p) == 1:
            return f"Euclid's theorem verified: {p} does not divide {a}, gcd({a}, {p}) = 1"
        else:
            return f"Euclid's theorem is not applicable for {p} and {a} (gcd ≠ 1)"
    else:
        return f"{p} is not a prime number or invalid input."

p_value = 17
a_value = 8
result = euclids_theorem(p_value, a_value)
print(result)


#fermat
def fermats_theorem(p, a):
    def mod_exp(base, exp, mod):
        result = 1
        base = base % mod
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % mod
            exp //= 2
            base = (base * base) % mod
        return result

    # Helper for primality check
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    if is_prime(p) and a % p != 0:
        if mod_exp(a, p - 1, p) == 1:
            return f"Fermat's theorem verified: {a} ^ {p-1} ≡ 1 (mod {p})"
        else:
            return f"Fermat's theorem not verified for {p} and {a}"
    else:
        return f"{p} is not a prime number or {a} is divisible by {p}"

p_value = 7
a_value = 3
result = fermats_theorem(p_value, a_value)
print(result)


#greedy
def greedy_set_cover(universe, subsets):
    elements = set(universe)
    chosen_sets = []
    while elements:
        best_set = None
        max_covered = set()
        for subset in subsets:
            covered = elements.intersection(subset)
            if len(covered) > len(max_covered):
                best_set = subset
                max_covered = covered
        if not best_set:
            break
        chosen_sets.append(best_set)
        elements -= max_covered
    return chosen_sets

universe_elements = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
sets = [{1, 2, 3, 4, 5}, {2, 5, 7, 8}, {1, 4, 6, 9}, {3, 6, 9, 10}]
result = greedy_set_cover(universe_elements, sets)

print("Chosen sets to cover the universe:")
for s in result:
    print(s)


#bubble sort
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]
print("Original array:", arr)
sorted_arr = bubble_sort(arr)
print("Sorted array:", sorted_arr)


#selection sort
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [64, 25, 12, 22, 11]
print("The sorted array:")
print(selection_sort(arr))


#insertion sort
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

arr = [5, 2, 4, 6, 1, 3]
print("The sorted array:")
print(insertion_sort(arr))


#floyd 
def floydWarshall(dist):
    V = len(dist)
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if dist[i][k] != INF and dist[k][j] != INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

if __name__ == "__main__":
    INF = 100000000
    dist = [
        [0, 4, INF, 5, INF],
        [INF, 0, 1, INF, 6],
        [2, INF, 0, 3, INF],
        [INF, INF, 1, 0, 2],
        [1, INF, INF, 4, 0]
    ]
    floydWarshall(dist)
    print("Shortest distance matrix using Floyd-Warshall Algorithm:")
    for i in range(len(dist)):
        for j in range(len(dist)):
            if dist[i][j] == INF:
                print("INF", end=" ")
            else:
                print(dist[i][j], end=" ")
        print()


#strasen
def split_matrix(matrix):
    n = len(matrix)
    mid = n // 2
    A = [row[:mid] for row in matrix[:mid]]
    B = [row[mid:] for row in matrix[:mid]]
    C = [row[:mid] for row in matrix[mid:]]
    D = [row[mid:] for row in matrix[mid:]]
    return A, B, C, D

def add_matrix(matrix1, matrix2):
    return [[matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))]

def subtract_matrix(matrix1, matrix2):
    return [[matrix1[i][j] - matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))]

def strassen_multiply(matrix1, matrix2):
    if len(matrix1) == 1:
        return [[matrix1[0][0] * matrix2[0][0]]]

    A, B, C, D = split_matrix(matrix1)
    E, F, G, H = split_matrix(matrix2)

    P1 = strassen_multiply(A, subtract_matrix(F, H))
    P2 = strassen_multiply(add_matrix(A, B), H)
    P3 = strassen_multiply(add_matrix(C, D), E)
    P4 = strassen_multiply(D, subtract_matrix(G, E))
    P5 = strassen_multiply(add_matrix(A, D), add_matrix(E, H))
    P6 = strassen_multiply(subtract_matrix(B, D), add_matrix(G, H))
    P7 = strassen_multiply(subtract_matrix(A, C), add_matrix(E, F))

    n = len(matrix1)
    result = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n // 2):
        for j in range(n // 2):
            result[i][j] = P5[i][j] + P4[i][j] - P2[i][j] + P6[i][j]
            result[i][j + n // 2] = P1[i][j] + P2[i][j]
            result[i + n // 2][j] = P3[i][j] + P4[i][j]
            result[i + n // 2][j + n // 2] = P5[i][j] + P1[i][j] - P3[i][j] - P7[i][j]

    return result

matrix1 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
]

matrix2 = [
    [17, 18, 19, 20],
    [21, 22, 23, 24],
    [25, 26, 27, 28],
    [29, 30, 31, 32]
]

result_matrix = strassen_multiply(matrix1, matrix2)
print("Result of matrix multiplication using Strassen's algorithm:")
for row in result_matrix:
    print(row)



